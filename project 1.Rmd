---
title: "Project 1"
author: "Yuzhi Li"
date: "2022-09-06"
output: html_document
---

## **Data Processing**
## **First Step**

```{r,include=FALSE}
library(readr)
sheet1 <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
```

### 1. Select the following columns: Area_name, STCOU, column that ends in "D"

```{r}
library(dplyr)
sheet1<- as_tibble(sheet1)
dat1<-sheet1 %>% select(Area_name, STCOU, ends_with("D")) %>% rename("area_name"=Area_name)
```

### 2. Convert the data into long format where each row has only one enrollment value for that Area_name.

```{r}
library(tidyr)
dat1_long<- dat1 %>% pivot_longer(cols = 3:12, names_to ="iterm_id", values_to="value")
```

### 3. Creat two more variable to represent "year" and "type" of the survey.

```{r}
dat1_new<-dat1_long %>% mutate(type=substr(iterm_id, start=1, stop=7), year=substr(iterm_id, start = 8, stop=9))

dat1_new$year<-format(as.Date(dat1_new$year, format = "%y"),"%Y") 
dat1_new <- transform(dat1_new, year=as.numeric(year))
dat1_new <-as_tibble(dat1_new)
dat1_new
```

### 4. create two data sets:
* one data set that contains only non-county data: dat1_new_nc
* one data set that contains only county level data: data1_new_c

```{r}
dat1_c<- dat1_new[grep(", \\w\\w", dat1_new$area_name, value=FALSE),]
dat1_c
class(dat1_c)<- c("county", class(dat1_c))
class(dat1_c)
dat1_nc<- dat1_new[-grep(", \\w\\w", dat1_new$area_name, value=FALSE),]
dat1_nc
class(dat1_nc)<- c("state", class(dat1_nc))
class(dat1_nc)
```

### 5. Create new vairables to indicate the state of each county level tibble.

```{r}
dat1_c$sate<- substr(dat1_c$area_name, nchar(dat1_c$area_name)-1, nchar(dat1_c$area_name)) 
as_tibble(dat1_c)
```

### 6. Create a new variable "division" for the non-county level tibble

```{r}
dat1_nc <- within(dat1_nc,{
   division = "ERROR"})
dat1_nc <- within(dat1_nc,{
   division[] = "ERROR"
   division[area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT")] = "Division1"
   division[area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA")] = "Division2"
   division[area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN")] = "Division3"
   division[area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA")] = "Division4"
   division[area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "WEST VIRGINIA")] = "Division5"
    division[area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE")] = "Division6"
    division[area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS")] = "Division7"
    division[area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING")] = "Division8"
    division[area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON")] = "Division9"
}) 
as_tibble(dat1_nc)
```

## Write functions of the 6 steps for 2nd component of the data set.

* function for steps 1 & 2.

Read the data:

```{r,include=FALSE}
library(readr)
library(dplyr)
library(tidyr)
sheet2 <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
```

Modify the data based on the requirement:

```{r}
function1_2 <- function(df){
  datf<- df %>% select(Area_name, STCOU, ends_with("D")) %>% rename("area_name"=Area_name)
  datf_long<- datf %>% pivot_longer(cols = 3:12, names_to = "iterm_id", values_to="value")
return(datf_long)
}
```
Apply function to data "sheet2"

```{r}
datf_long<-function1_2(sheet2)
```

* function for step 3.

```{r}
function3<- function(datf_long){
  datf_new<-datf_long %>% mutate(type=substr(iterm_id, start=1, stop=7),     year=substr(iterm_id, start = 8, stop=9))
  datf_new$year<-format(as.Date(datf_new$year, format = "%y"),"%Y") 
  datf_new <- transform(datf_new, year=as.numeric(year)) 
return(datf_new)
}
```

Apply function to result from step 1 & 2:
```{r}
datf_new <- function3(datf_long)
```

* function for step 5.

```{r}
function5<- function(df){
  df$state<- substr(df$area_name, nchar(df$area_name)-1, nchar(df$area_name)) 
return(df)
  }
```

* function for step 6.

```{r}
function6<-function(df){
df <- within(df,{
   division = "ERROR"})
df <- within(df,{
   division[] = "ERROR"
   division[area_name %in% c("CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND", "VERMONT")] = "Division1"
   division[area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA")] = "Division2"
   division[area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN")] = "Division3"
   division[area_name %in% c("IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA")] = "Division4"
   division[area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "WEST VIRGINIA")] = "Division5"
    division[area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE")] = "Division6"
    division[area_name %in% c("ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS")] = "Division7"
    division[area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING")] = "Division8"
    division[area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON")] = "Division9"
}) 
return(df)
}
```

* Write function for step 4 and call functions for step 5 and step 6.

```{r}
function4<-function(df){
  
df1<- df[grep(", \\w\\w", df$area_name, value=FALSE),]
class(df1)<- c("county", class(df1))

df2<- df[-grep(", \\w\\w", df$area_name, value=FALSE),]
class(df2)<- c("state", class(df2))

return (list(datf_c=as_tibble(df1), datf_nc=as_tibble(df2)))
}

#Apply function4 for dataframe datf_new (result from function3)
function4(datf_new)

#Call function5 and function6
function5(function4(datf_new)$datf_c)
function6(function4(datf_new)$datf_nc)
```

### Create a wrapper function for above 6 steps:

```{r}
my_wrapper<- function(url){
  df <- read_csv(url)
  datf_long<- function1_2(df)
  datf_new <- function3(datf_long)
  function4(datf_new)
  data_c<-function5(function4(datf_new)$datf_c)
  data_nc<-function6(function4(datf_new)$datf_nc)
  return(list(as_tibble(data_c), as_tibble(data_nc)))
}
```

## Use the function created above and combined county level data and non-county level data.

```{r,echo=TRUE, include=FALSE}
a<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
b<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
```
```{r}
dat_county <- dplyr::bind_rows(a[[1]], b[[1]])
dat_non_county<- dplyr::bind_rows(a[[2]], b[[2]])
as_tibble(dat_county)
as_tibble(dat_non_county)
```

## Wrting a Generic Function for Summarizing

### Function of plot for state data:

```{r}
library(ggplot2)
plot.state <- function(df, var_name = "value" ){
  new_df<- df %>% group_by(division,year) %>% summarise(Mean=mean(get(var_name))) %>% subset(division != "ERROR")
  ggplot(new_df,aes(x=year, y=Mean, color = division )) + geom_line()
}
plot.state(dat_non_county)
```

### Function of plot for county data:

```{r}
plot.county <- function(df, ST="AL", order="top", x=5, var_name = "value"){
  df1 <- df %>% filter(state==ST) %>% group_by(area_name) %>% summarise(Mean=mean(get(var_name))) %>% arrange(desc(Mean))
  if(order=="top") {
    df2 <- df1[1:x,]
  }
  if(order=="bottom"){
    df2 <- tail(df1,n=x)
  }
  new_df <- dat_county %>% filter(state==ST) %>% subset(area_name %in% df2$area_name)
  ggplot(new_df, aes(x= year, y= get(var_name), color= area_name))+geom_line()
} 
```

## Put it Together

### Read the previous two data sets and create two data frames by using the wrapper function:

```{r}
a<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
b<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
```

### Run the data combining function to create state data frame and county data frame:

```{r}
dat_county <- dplyr::bind_rows(a[[1]], b[[1]])
dat_non_county<- dplyr::bind_rows(a[[2]], b[[2]])
as_tibble(dat_county)
as_tibble(dat_non_county)
```

### Use the plot function on state data frame:

```{r}
plot.state(dat_non_county)
```

### Use the plot function on the county data frame:

* State to be "PA", the group being the top, number looked at being 7:

```{r}
plot.county(dat_county, ST="PA", order="top", x=7, var_name = "value")
```

* State to be "PA", the group being the bottom, number looked at being 4:

```{r}
plot.county(dat_county, ST="PA", order="bottom", x=4, var_name = "value")
```

* Default output for the plot function:

```{r}
plot.county(dat_county, var_name = "value")
```

* State to be "MN", the group being the top, number looked at being 10:

```{r}
plot.county(dat_county, ST="MN", order="top", x=10, var_name = "value")
```

### Run the data processing function on the four data sets below:

#### Use wrapper function to read and subset data

```{r}
c<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01a.csv")
d<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01b.csv")
e<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01c.csv")
f<- my_wrapper("https://www4.stat.ncsu.edu/~online/datasets/PST01d.csv")
```

#### Run the data combining function to put these into two data frames:

```{r}
cdef_county <- dplyr::bind_rows(c[[1]], d[[1]], e[[1]], f[[1]])
cdef_non_county<- dplyr::bind_rows(c[[2]], d[[2]], e[[2]], f[[2]])
as_tibble(cdef_county)
as_tibble(cdef_non_county)
```

#### Use the plot function on the **state** data frame:

```{r}
plot.state(cdef_non_county)
```

#### Use the plot function on the **county** data frame:

* State to be "CT", the group being the top, number looked at being 6:

```{r}
plot.county(cdef_county, ST="CT", order="top", x=6, var_name = "value")
```

* State to be "NC", the group being the bottom, number looked at being 10:

```{r}
plot.county(cdef_county, ST="NC", order="bottom", x=10, var_name = "value")
```

* Default output for the plot function:

```{r}
plot.county(cdef_county, var_name = "value")
```

* State to be "MN", the group being the top, number looked at being 4:

```{r}
plot.county(cdef_county, ST="MN", order="top", x=4, var_name = "value")
```









